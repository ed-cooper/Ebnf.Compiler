/*
 * IMPORTANT:
 * This code has been automatically generated by a tool.
 * Any modifications to this code will not be kept.
 * 
 * This file was last generated at 17.11.2018 09:20:10
 */

using System.Collections.Generic;
using System.Text.RegularExpressions;

[assembly: System.CLSCompliant(true)]

namespace Test
{
    /// <summary>
    /// Provides methods for validating a string to the Test specification.
    /// </summary>
    public static class Validation
    {
        /// <summary>
        /// Range=!"[a-z]+"
        /// </summary>
        /// <param name="input">The input string to validate.</param>
        /// <param name="remainder">The part of the string that did not match the given rule set; empty if full match.</param>
        /// <param name="parseTree">The parse tree produced from the input.</param>
        /// <param name="level">The internal level of recursion; starts at 0.</param>
        public static bool IsRange(string input, out string remainder, out Node parseTree, int level = 0)
        {
            parseTree = new Node(NodeType.Range);
            Node newNode;
            remainder = input;
            // !"[a-z]+"
            var regex = new Regex("[a-z]+");
            var match = regex.Match(remainder);
            if (match.Success)
            {
                if (remainder.StartsWith(" "))
                {
                    remainder = remainder.Remove(0, match.Groups[0].Value.Length + 2);
                }
                else
                {
                    remainder = remainder.Remove(0, match.Groups[0].Value.Length);
                }
                parseTree.Value = match.Groups[0].Value;
                return true;
            }
            parseTree.Children.Clear();
            remainder = input;
            return false;
        }

        /// <summary>
        /// keyword="struct"|"enum"
        /// </summary>
        /// <param name="input">The input string to validate.</param>
        /// <param name="remainder">The part of the string that did not match the given rule set; empty if full match.</param>
        /// <param name="parseTree">The parse tree produced from the input.</param>
        /// <param name="level">The internal level of recursion; starts at 0.</param>
        public static bool Iskeyword(string input, out string remainder, out Node parseTree, int level = 0)
        {
            parseTree = new Node(NodeType.keyword);
            Node newNode;
            remainder = input;
            // "struct"
            if (remainder.StartsWith("struct"))
            {
                remainder = remainder.Substring(6);
                parseTree.Value = input.Substring(0, input.Length - remainder.Length);
                return true;
            }
            parseTree.Children.Clear();
            remainder = input;
            // "enum"
            if (remainder.StartsWith("enum"))
            {
                remainder = remainder.Substring(4);
                parseTree.Value = input.Substring(0, input.Length - remainder.Length);
                return true;
            }
            parseTree.Children.Clear();
            remainder = input;
            return false;
        }

        /// <summary>
        /// Struct=keyword,Range,":"
        /// </summary>
        /// <param name="input">The input string to validate.</param>
        /// <param name="remainder">The part of the string that did not match the given rule set; empty if full match.</param>
        /// <param name="parseTree">The parse tree produced from the input.</param>
        /// <param name="level">The internal level of recursion; starts at 0.</param>
        public static bool IsStruct(string input, out string remainder, out Node parseTree, int level = 0)
        {
            parseTree = new Node(NodeType.Struct);
            Node newNode;
            remainder = input;
            // keyword
            if (Iskeyword(remainder, out remainder, out newNode, level + 1))
            {
                parseTree.Children.Add(newNode);
                // Range
                if (IsRange(remainder, out remainder, out newNode, level + 1))
                {
                    parseTree.Children.Add(newNode);
                    // ":"
                    if (remainder.StartsWith(":"))
                    {
                        remainder = remainder.Substring(1);
                        parseTree.Value = input.Substring(0, input.Length - remainder.Length);
                        return true;
                    }
                }
            }
            parseTree.Children.Clear();
            remainder = input;
            return false;
        }

    }

    /// <summary>
    /// Represents a node in a parse tree.
    /// </summary>
    public class Node
    {
        #region Properties

        /// <summary>
        /// Gets or sets the string text that this node represents.
        /// </summary>
        public string Value { get; set; }

        /// <summary>
        /// Gets or sets the type of this node.
        /// </summary>
        public NodeType TypeName { get; set; }

        /// <summary>
        /// Gets or sets the collection of child nodes to this node.
        /// </summary>
        public List<Node> Children { get; set; }

        #endregion

        #region Constructor

        /// <summary>
        /// Creates a new instance of the <see cref="Node"/> class.
        /// </summary>
        public Node()
        {
            Children = new List<Node>();
        }

        /// <summary>
        /// Creates a new instance of the <see cref="Node"/> class.
        /// </summary>
        /// <param name="typeName">The type of the node.</param>
        public Node(NodeType typeName)
        {
            Value = "";
            Children = new List<Node>();
            TypeName = typeName;
        }

        #endregion

        #region Methods

        /// <summary>
        /// Returns a string that represents the current object.
        /// </summary>
        public override string ToString()
        {
            return TypeName.ToString() + ": Value";
        }

        #endregion
    }
    /// <summary>
    /// Represents all the possible types of node in the parse tree.
    /// </summary>
    public enum NodeType
    {
        /// <summary>
        /// Range=!"[a-z]+"
        /// </summary>
        Range,
        /// <summary>
        /// keyword="struct"|"enum"
        /// </summary>
        keyword,
        /// <summary>
        /// Struct=keyword,Range,":"
        /// </summary>
        Struct,
    }
}
